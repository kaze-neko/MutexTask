package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time" 
)

func TestAddPostsConcurrent() { // Проверка добавления постов из 1000 горутин
	// Инициализация массива постов
	postArr = make([]Post, 0)// переписать

	// Запускаем 1000 горутин для добавления постов
	for i := 0; i < 1000; i++ {
		wg.Add(1) // Увеличиваем счётчик ожидания
		go func() {
			defer wg.Done()                                              // Уменьшаем счётчик после завершения горутины
			time.Sleep(time.Millisecond * time.Duration(rand.Intn(100))) // Случайная задержка перед добавлением постов
			for j := 0; j < 5; j++ {                                     // Добавляем 5 постов из списка
				index := rand.Intn(len(messagedata)) // Выбор случайного индекса из массива сообщения (либо убрать или перемещивание по ссылке)
				addPost(messagedata[index])          // Добавление поста в массив
			}
		}()
	}
	wg.Wait()
	// Проверка количества постов
	if len(postArr) == postLimit {
		fmt.Printf("Успех! Количество постов: %d\n", len(postArr))
	} else {
		fmt.Printf("Ошибка: Неверное количество постов: %d\n", len(postArr))
	}
}

func TestReadPostsAboutGo() { //Проверка подсчета постов, обсуждающих Go.
	println(len(postArr))
	// Запускаем читателей
	wg2 := &sync.WaitGroup{} // Создаём группу ожидания для читателей
	currentPost := 0         // Переменная для отслеживания текущего поста
	cnt := 0                 // Счётчик постов о Go

	wg2.Add(1) // Увеличиваем счётчик ожидания для читателя
	go func() {
		defer wg2.Done() // Уменьшаем счётчик после завершения горутины
		for {
			//mu.RLock() // Захват мьютекса для чтения (убр)
			// Условие завершения: флаг == false и текущий пост равен длине массива постов
			if !flag && currentPost == len(postArr) {
				//mu.RUnlock() // Освобождаем мьютекс (убрать)
				break        // Завершаем цикл, если нет новых постов
			}
			// Проверяем, если текущий пост меньше длины массива
			if currentPost < len(postArr) {
				post := postArr[currentPost] // Получаем текущий пост
				if post.IsTalkingAboutGo() { // Проверяем, обсуждает ли пост Go
					cnt++ // Увеличиваем счётчик, если пост о Go
				}
				currentPost++ // Переходим к следующему посту
			}
			//mu.RUnlock()    (убр)                                             // Освобождаем мьютекс для чтения
			//time.Sleep(time.Millisecond * time.Duration(rand.Intn(100))) // Случайная задержка перед следующей проверкой (убрать)
		}
	}()

	flag = false // Устанавливаем флаг завершения для читателя
	wg2.Wait()   // Ждем завершения всех горутин добавления постов

	// Ждем завершения читателя
	wg2.Wait()

	// Проверка количества постов о golang
	if cnt == 3000 {
		fmt.Printf("Количество постов о golang: %d\n", cnt)
	} else {
		fmt.Printf("Количество постов о golang не соответствуют: %d\n", cnt)
	}
}

func main() {
	TestAddPostsConcurrent()
	TestReadPostsAboutGo()
}

//Организовать тест чтобы не пропадали сообщения
// запустить много потоков например 1000 потоков и каждый поток по 5 сообщений (длина массив должна получиться 5000), если меньше, то тест не пройден

//2)Организовать несколько читающих потоков (RLock, RUnlock) 1 читаюший (Lock, unlock) и проверить кол-во считанных равно кол-во сообщений

// 3) Структура которая хронит сообщение и должна быть структура которая записывает сообщение
// файл post структура post и структура хранилище postов хранит сообщения и функция добавления add post
